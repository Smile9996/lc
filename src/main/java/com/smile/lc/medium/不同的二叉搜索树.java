package com.smile.lc.medium;

public class 不同的二叉搜索树 {

    public static void main(String[] args) {
        System.out.println(method(10));
    }


    /**
     * 动态规划
     * 对于一个节点 i，假设其左子树的节点数为 i-1，其右子树的节点数为 n-i
     * 那么对于节点 i 可能组成的二叉搜索树的数量为左子树的可能组成二叉搜索树的数量和右子树的可能组成二叉搜索树的笛卡尔积 f(i) = G(i-1) * G(n-i)
     * 而对于每一个节点都有 G(n) = f(1) + f(2) + ··· + f(n)
     * 所以 G(n) = G(1-1)*G(n-1) + G(2-1)*G(n-2) + ··· + G(n-1)*G(1-1)
     * = G(0)*G(n-1) + G(1)*G(n-2) + ··· + G(n-2)G(1) + G(n-1)*G(0)
     * 得到卡特兰数公式
     */

    /**
     * 设给的长度为4（1，2，3，4）
     * 所以就要考虑1，2，3，4都当作根节点的情况
     * 设 f(i) 为这个数字当做根节点时的不同的二叉搜索树的数量，设 G(k) 为 k 个节点能组成多少种不同的二叉搜索树
     * 每个节点当作根节点时能组成的不同的二叉搜索树为不同左子树与不同右子树的笛卡尔积，即左子树的数量 * 右子树的数量
     * f(i) = G(i-1) * G(n-i)
     * 1 当作根节点
     *      其左边有 0 个节点，右边有 3 个节点
     *      所以 f(1) = G(0) * G(3)
     * 2 当作根节点
     *      其左面有 1 个节点，右边有 2 个节点
     *      所以 f(2) = G(1) * G(2)
     * 3 当作根节点
     *      其左边有 2 个节点，右边有 1 个节点
     *      所以 f(3) = G(2) * G(1)
     * 4 当作根节点
     *      其左边有 3 个节点，右边有 0 个节点
     *      所以 f(4) = G(3) * G(0)
     * 所以 四个节点能组成 G(4) 种不同的二叉搜索树
     * 而 G(4) 有四种情况
     * 所以 G(4) = f(1) + f(2) + f(3) + f(4)
     *          = G(0) * G(3) + G(1) * G(2) + G(2) * G(1) + G(3) * G(0)
     * 除已知的 G(0) = 1, G(1) = 1
     * 其他的 G(i>1) 函数 都需要继续借用 f(i) 函数求值
     * 所以我们必须先求得 G(2), 依次去求得 G(3), G(4) ... G(n)
     * 可以使用两个函数递归到只剩 G(0) 和 G(1)
     *
     * 依据上面的推论
     * 可得
     * G(n) = G(0) * (n-1) + G(1) * G(n-2) + ... + G(n-2) * G(1) + G(n-1) * G(0)
     *      = ∑(i=1,n) G(i-1) * G(n-i)
     *
     * 所以我们用 i 限定 节点的数量
     * 用 j 来标识 根节点的位置
     * 逐步求得 G(2),G(3),...,G(n-1),供 G(n) 使用
     *
     * 对于 n = 4 的例子
     * G(0), G(1) 为已知
     * i = 2
     *   j = 1
     * ``G[2] += G[0] * G[1] = G[0] + G[0]
     *   j = 2
     * ``G[2] += G[1] * G[0} = G[2] + G[1] * G[0}
     * ``G[2] 现在已经求出值了， 可以供求 G[3] 使用
     * 接下来就可以依次求到G[n]
     */
    public static int method(int n) {
        int[] G= new int[n+1];
        G[0] = 1;
        G[1] = 1;
        for (int i = 2; i < n + 1; i ++) {
            // 这里是判断以 j 为根节点的情况
            for (int j = 1; j < i + 1; j ++) {
                G[i] += G[j-1] * G[i-j];
            }
        }
        return G[n];
    }
}
